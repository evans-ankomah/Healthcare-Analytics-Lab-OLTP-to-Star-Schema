================================================================================
ETL DESIGN - OLTP to Star Schema Transformation
================================================================================
Healthcare Analytics Lab: OLTP to Star Schema
Part 3: ETL Logic

This document describes the Extract, Transform, Load (ETL) process for 
populating the star schema from the normalized OLTP database.

KEY PRINCIPLE: AGGRESSIVE DENORMALIZATION
-----------------------------------------
The fact table includes denormalized attributes (year, month, specialty_name,
department_name, etc.) to enable ZERO-JOIN analytical queries.

================================================================================
ETL OVERVIEW
================================================================================

Source: OLTP Database (10 normalized tables)
Target: Star Schema (8 dimensions + 1 fact + 2 bridges)

ETL Flow:
1. Load Dimension Tables (in dependency order)
2. Load Fact Table (with dimension lookups + denormalization)
3. Load Bridge Tables (many-to-many relationships)

================================================================================
DIMENSION LOAD LOGIC
================================================================================

--------------------------------------------------------------------------------
1. DIM_DATE (One-Time Load)
--------------------------------------------------------------------------------

Purpose: Pre-populate all dates for the analysis period (2+ years)

SQL Implementation:

```sql
INSERT INTO dim_date 
SELECT 
    CAST(DATE_FORMAT(d.date, '%Y%m%d') AS UNSIGNED) AS date_key,
    d.date AS calendar_date,
    YEAR(d.date) AS year,
    QUARTER(d.date) AS quarter,
    MONTH(d.date) AS month,
    MONTHNAME(d.date) AS month_name,
    WEEKOFYEAR(d.date) AS week_of_year,
    DAY(d.date) AS day_of_month,
    DAYOFWEEK(d.date) AS day_of_week,
    DAYNAME(d.date) AS day_name,
    DAYOFWEEK(d.date) IN (1, 7) AS is_weekend,
    YEAR(d.date) AS fiscal_year,           -- Adjust for company's fiscal year
    QUARTER(d.date) AS fiscal_quarter      -- Adjust for company's fiscal year
FROM (
    -- Generate dates from 2020-01-01 to 2026-12-31
    SELECT DATE_ADD('2020-01-01', INTERVAL n DAY) AS date
    FROM (SELECT @row := @row + 1 AS n FROM 
          (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) t1,
          (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) t2,
          (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) t3,
          (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5) t4,
          (SELECT @row := -1) t0
    ) numbers
    WHERE DATE_ADD('2020-01-01', INTERVAL n DAY) <= '2026-12-31'
) d;
```

Load Strategy: Full load once, then add new dates as needed.

--------------------------------------------------------------------------------
2-7. OTHER DIMENSION TABLES (Specialties, Departments, Providers, etc.)
--------------------------------------------------------------------------------

Standard dimension loads - see previous documentation.
Key point: Load dimensions BEFORE fact table.

================================================================================
FACT TABLE LOAD LOGIC (WITH DENORMALIZATION)
================================================================================

This is the CRITICAL section. The fact table includes denormalized attributes
for zero-join queries.

--------------------------------------------------------------------------------
SQL IMPLEMENTATION:
--------------------------------------------------------------------------------

```sql
INSERT INTO fact_encounters (
    -- Dimension Foreign Keys
    encounter_id,
    encounter_date_key,
    discharge_date_key,
    patient_key,
    provider_key,
    department_key,
    encounter_type_key,
    specialty_key,
    primary_diagnosis_key,
    
    -- DENORMALIZED DATE ATTRIBUTES (Zero-Join)
    encounter_date,
    discharge_date,
    encounter_year,
    encounter_month,
    encounter_month_name,
    encounter_quarter,
    encounter_day_of_week,
    is_weekend,
    
    -- DENORMALIZED DIMENSION ATTRIBUTES (Zero-Join)
    specialty_name,
    specialty_code,
    department_name,
    provider_name,
    encounter_type,
    is_inpatient,
    primary_icd10_code,
    primary_icd10_description,
    
    -- PRE-AGGREGATED METRICS
    diagnosis_count,
    procedure_count,
    total_claim_amount,
    total_allowed_amount,
    claim_count,
    
    -- PRE-COMPUTED DERIVED METRICS
    length_of_stay_hours,
    length_of_stay_days,
    is_readmission,
    days_since_last_visit
)
SELECT 
    -- Dimension Foreign Keys
    e.encounter_id,
    CAST(DATE_FORMAT(e.encounter_date, '%Y%m%d') AS UNSIGNED),
    CAST(DATE_FORMAT(e.discharge_date, '%Y%m%d') AS UNSIGNED),
    dp.patient_key,
    dprov.provider_key,
    ddept.department_key,
    det.encounter_type_key,
    ds.specialty_key,
    dd.diagnosis_key,
    
    -- DENORMALIZED DATE ATTRIBUTES
    e.encounter_date,
    e.discharge_date,
    YEAR(e.encounter_date),
    MONTH(e.encounter_date),
    MONTHNAME(e.encounter_date),
    QUARTER(e.encounter_date),
    DAYOFWEEK(e.encounter_date),
    DAYOFWEEK(e.encounter_date) IN (1, 7),
    
    -- DENORMALIZED DIMENSION ATTRIBUTES
    s.specialty_name,
    s.specialty_code,
    dept.department_name,
    CONCAT(prov.first_name, ' ', prov.last_name),
    e.encounter_type,
    e.encounter_type = 'Inpatient',
    diag.icd10_code,
    diag.icd10_description,
    
    -- PRE-AGGREGATED METRICS
    COALESCE(ed_count.cnt, 0),
    COALESCE(ep_count.cnt, 0),
    COALESCE(b.total_claim, 0),
    COALESCE(b.total_allowed, 0),
    COALESCE(b.claim_count, 0),
    
    -- PRE-COMPUTED DERIVED METRICS
    TIMESTAMPDIFF(HOUR, e.encounter_date, e.discharge_date),
    DATEDIFF(e.discharge_date, e.encounter_date),
    -- is_readmission (calculated separately)
    FALSE,
    -- days_since_last_visit (calculated separately)
    NULL

FROM oltp.encounters e

-- Join to get FK lookups and denormalized attributes
INNER JOIN oltp.providers prov ON e.provider_id = prov.provider_id
INNER JOIN oltp.specialties s ON prov.specialty_id = s.specialty_id
INNER JOIN oltp.departments dept ON e.department_id = dept.department_id

-- Join to dimension tables for surrogate keys
INNER JOIN dim_patient dp ON dp.patient_id = e.patient_id
INNER JOIN dim_provider dprov ON dprov.provider_id = e.provider_id
INNER JOIN dim_department ddept ON ddept.department_id = e.department_id
INNER JOIN dim_specialty ds ON ds.specialty_id = s.specialty_id
INNER JOIN dim_encounter_type det ON det.type_name = e.encounter_type

-- Get primary diagnosis
LEFT JOIN oltp.encounter_diagnoses ed_prim 
    ON e.encounter_id = ed_prim.encounter_id AND ed_prim.diagnosis_sequence = 1
LEFT JOIN oltp.diagnoses diag ON ed_prim.diagnosis_id = diag.diagnosis_id
LEFT JOIN dim_diagnosis dd ON dd.diagnosis_id = diag.diagnosis_id

-- Pre-aggregated counts
LEFT JOIN (
    SELECT encounter_id, COUNT(*) AS cnt 
    FROM oltp.encounter_diagnoses GROUP BY encounter_id
) ed_count ON e.encounter_id = ed_count.encounter_id

LEFT JOIN (
    SELECT encounter_id, COUNT(*) AS cnt 
    FROM oltp.encounter_procedures GROUP BY encounter_id
) ep_count ON e.encounter_id = ep_count.encounter_id

-- Pre-aggregated billing
LEFT JOIN (
    SELECT encounter_id, 
           SUM(claim_amount) AS total_claim,
           SUM(allowed_amount) AS total_allowed,
           COUNT(*) AS claim_count
    FROM oltp.billing GROUP BY encounter_id
) b ON e.encounter_id = b.encounter_id;
```

--------------------------------------------------------------------------------
STEP 2: CALCULATE READMISSION FLAG
--------------------------------------------------------------------------------

The is_readmission flag requires comparing each encounter to previous ones.
This is done AFTER the initial load using a window function:

```sql
UPDATE fact_encounters f
INNER JOIN (
    SELECT 
        encounter_key,
        CASE 
            WHEN is_inpatient = TRUE 
             AND LAG(discharge_date) OVER (
                     PARTITION BY patient_key 
                     ORDER BY encounter_date
                 ) IS NOT NULL
             AND DATEDIFF(encounter_date, 
                     LAG(discharge_date) OVER (
                         PARTITION BY patient_key 
                         ORDER BY encounter_date
                     )
                 ) <= 30
            THEN TRUE 
            ELSE FALSE 
        END AS is_readmission,
        DATEDIFF(encounter_date, 
            LAG(encounter_date) OVER (
                PARTITION BY patient_key 
                ORDER BY encounter_date
            )
        ) AS days_since_last_visit
    FROM fact_encounters
) calc ON f.encounter_key = calc.encounter_key
SET f.is_readmission = calc.is_readmission,
    f.days_since_last_visit = calc.days_since_last_visit;
```

This eliminates the expensive self-join at query time!


================================================================================
BRIDGE TABLE LOAD LOGIC
================================================================================

--------------------------------------------------------------------------------
BRIDGE_ENCOUNTER_DIAGNOSES
--------------------------------------------------------------------------------

```sql
INSERT INTO bridge_encounter_diagnoses (encounter_key, diagnosis_key, diagnosis_sequence)
SELECT 
    f.encounter_key,
    dd.diagnosis_key,
    ed.diagnosis_sequence
FROM oltp.encounter_diagnoses ed
INNER JOIN fact_encounters f ON f.encounter_id = ed.encounter_id
INNER JOIN dim_diagnosis dd ON dd.diagnosis_id = ed.diagnosis_id;
```

--------------------------------------------------------------------------------
BRIDGE_ENCOUNTER_PROCEDURES
--------------------------------------------------------------------------------

```sql
INSERT INTO bridge_encounter_procedures (encounter_key, procedure_key, procedure_date)
SELECT 
    f.encounter_key,
    dpr.procedure_key,
    ep.procedure_date
FROM oltp.encounter_procedures ep
INNER JOIN fact_encounters f ON f.encounter_id = ep.encounter_id
INNER JOIN dim_procedure dpr ON dpr.procedure_id = ep.procedure_id;
```


================================================================================
HANDLING MISSING DATA
================================================================================

| Scenario                | Solution                                      |
|-------------------------|-----------------------------------------------|
| Unknown dimension keys  | Use special "-1" or "Unknown" dimension record|
| NULL billing amounts    | Default to 0                                  |
| NULL discharge_date     | Use NULL (outpatient encounters)              |
| Missing diagnoses       | diagnosis_count = 0, primary_icd10_code = NULL|
| Missing procedures      | procedure_count = 0                           |


================================================================================
REFRESH STRATEGY
================================================================================

--------------------------------------------------------------------------------
RECOMMENDED: INCREMENTAL DAILY REFRESH
--------------------------------------------------------------------------------

Frequency: Daily at 2:00 AM (after OLTP system quiet period)

Process:
1. Identify new/changed records since last ETL run
2. Update dimensions first (to ensure keys exist)
3. Insert new fact records with all denormalized attributes
4. Update readmission flags for new encounters
5. Update bridge tables for new encounters
6. Log completion and row counts

--------------------------------------------------------------------------------
LATE-ARRIVING FACTS (Billing Catch-Up):
--------------------------------------------------------------------------------

```sql
UPDATE fact_encounters f
LEFT JOIN (
    SELECT encounter_id, 
           SUM(claim_amount) AS total_claim,
           SUM(allowed_amount) AS total_allowed
    FROM oltp.billing GROUP BY encounter_id
) b ON f.encounter_id = b.encounter_id
SET f.total_claim_amount = COALESCE(b.total_claim, 0),
    f.total_allowed_amount = COALESCE(b.total_allowed, 0)
WHERE f.encounter_date >= DATE_SUB(CURRENT_DATE, INTERVAL 7 DAY)
  AND f.total_claim_amount = 0;
```


================================================================================
ETL EXECUTION ORDER
================================================================================

1. dim_date (if new dates needed)
2. dim_specialty
3. dim_department
4. dim_encounter_type
5. dim_diagnosis
6. dim_procedure
7. dim_patient
8. dim_provider (requires specialty, department)
9. fact_encounters (requires all dimensions, includes denormalization)
10. UPDATE fact_encounters (calculate readmission flags)
11. bridge_encounter_diagnoses (requires fact)
12. bridge_encounter_procedures (requires fact)

================================================================================
ETL OUTPUT SUMMARY
================================================================================

After ETL completion, the star schema supports ZERO-JOIN queries:

| Query Type                     | Joins Required | Why                    |
|--------------------------------|----------------|------------------------|
| Monthly encounters by specialty| 0              | All in fact table      |
| Revenue by specialty/month     | 0              | All in fact table      |
| Readmission rates by specialty | 0              | All in fact table      |
| Full diagnosis details         | 1-2            | Bridge + dim_diagnosis |
| Patient demographics           | 1              | dim_patient            |

================================================================================
