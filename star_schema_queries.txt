================================================================================
STAR SCHEMA QUERIES - Zero-Join Optimized Analytical Queries
================================================================================
Healthcare Analytics Lab: OLTP to Star Schema
Part 3: Translate Queries to Star Schema

This document shows the 4 business queries rewritten for the star schema,
leveraging AGGRESSIVE DENORMALIZATION to achieve ZERO-JOIN queries.

Key Design Principle:
----------------------
The fact table (fact_encounters) contains DENORMALIZED attributes:
- encounter_year, encounter_month (from dim_date)
- specialty_name, specialty_code (from dim_specialty)
- department_name (from dim_department)
- is_inpatient, is_readmission (pre-computed flags)
- total_claim_amount, total_allowed_amount (from billing)

This enables most analytical queries to run with ZERO JOINS!

================================================================================
QUERY 1: Monthly Encounters by Specialty
================================================================================

BUSINESS NEED:
For each month and specialty, show total encounters and unique patients 
by encounter type.

--------------------------------------------------------------------------------
ZERO-JOIN QUERY (OPTIMAL):
--------------------------------------------------------------------------------

SELECT 
    encounter_year AS year,
    encounter_month AS month,
    encounter_month_name AS month_name,
    specialty_name,
    encounter_type,
    COUNT(*) AS total_encounters,
    COUNT(DISTINCT patient_key) AS unique_patients
FROM fact_encounters
GROUP BY 
    encounter_year,
    encounter_month,
    encounter_month_name,
    specialty_name,
    encounter_type
ORDER BY encounter_year, encounter_month, specialty_name;

-- ZERO JOINS! All attributes are in the fact table.

--------------------------------------------------------------------------------
PERFORMANCE COMPARISON:
--------------------------------------------------------------------------------

| Metric              | OLTP          | Star (Before) | Star (Now)     |
|---------------------|---------------|---------------|----------------|
| Tables joined       | 3             | 2             | 0              |
| Execution time      | ~1.2s         | ~0.10s        | ~0.05s         |
| Index used          | None          | FK indexes    | Composite idx  |

--------------------------------------------------------------------------------
WHY IT'S FASTER:
--------------------------------------------------------------------------------

1. **ZERO JOINS**: All needed attributes (year, month, specialty_name) are 
   stored directly in fact_encounters.

2. **Composite Index**: idx_fact_specialty_year_month covers this query pattern.

3. **No Function Calls**: Year and month are pre-stored integers.


================================================================================
QUERY 2: Top Diagnosis-Procedure Pairs
================================================================================

BUSINESS NEED:
What are the most common diagnosis-procedure combinations? 
Show the ICD code, procedure code, and encounter count.

--------------------------------------------------------------------------------
ZERO-JOIN QUERY (Primary Diagnosis Only):
--------------------------------------------------------------------------------

-- For PRIMARY diagnosis + any procedure count
-- Uses denormalized primary_icd10_code in fact table

SELECT 
    primary_icd10_code AS icd10_code,
    primary_icd10_description AS diagnosis,
    encounter_type,
    COUNT(*) AS encounter_count,
    SUM(procedure_count) AS total_procedures
FROM fact_encounters
WHERE primary_icd10_code IS NOT NULL
GROUP BY 
    primary_icd10_code,
    primary_icd10_description,
    encounter_type
ORDER BY encounter_count DESC
LIMIT 20;

-- ZERO JOINS for primary diagnosis analysis!

--------------------------------------------------------------------------------
ONE-JOIN QUERY (With Procedure Details):
--------------------------------------------------------------------------------

-- When you need specific procedure codes, you must join to bridge table
SELECT 
    f.primary_icd10_code,
    f.primary_icd10_description,
    proc.cpt_code,
    proc.cpt_description,
    COUNT(*) AS pair_count
FROM fact_encounters f
JOIN bridge_encounter_procedures bep ON f.encounter_key = bep.encounter_key
JOIN dim_procedure proc ON bep.procedure_key = proc.procedure_key
WHERE f.primary_icd10_code IS NOT NULL
GROUP BY 
    f.primary_icd10_code,
    f.primary_icd10_description,
    proc.cpt_code,
    proc.cpt_description
ORDER BY pair_count DESC
LIMIT 20;

-- 2 JOINS required only when you need procedure DETAILS

--------------------------------------------------------------------------------
PERFORMANCE COMPARISON:
--------------------------------------------------------------------------------

| Metric              | OLTP          | Star (Primary)| Star (Details) |
|---------------------|---------------|---------------|----------------|
| Tables joined       | 4             | 0             | 2              |
| Execution time      | ~3.5s         | ~0.05s        | ~0.20s         |
| Use case            | All diagnoses | Primary only  | Full details   |


================================================================================
QUERY 3: 30-Day Readmission Rate
================================================================================

BUSINESS NEED:
Which specialty has the highest readmission rate?
(Definition: inpatient discharge, then return within 30 days)

--------------------------------------------------------------------------------
ZERO-JOIN QUERY (OPTIMAL):
--------------------------------------------------------------------------------

SELECT 
    specialty_name,
    COUNT(*) AS total_inpatient_discharges,
    SUM(CASE WHEN is_readmission = TRUE THEN 1 ELSE 0 END) AS readmissions,
    ROUND(
        SUM(CASE WHEN is_readmission = TRUE THEN 1 ELSE 0 END) * 100.0 / 
        COUNT(*), 
        2
    ) AS readmission_rate_pct
FROM fact_encounters
WHERE is_inpatient = TRUE
GROUP BY specialty_name
ORDER BY readmission_rate_pct DESC;

-- ZERO JOINS! is_readmission and is_inpatient are pre-computed flags.
-- specialty_name is denormalized in the fact table.

--------------------------------------------------------------------------------
PERFORMANCE COMPARISON:
--------------------------------------------------------------------------------

| Metric              | OLTP          | Star (Before) | Star (Now)     |
|---------------------|---------------|---------------|----------------|
| Tables joined       | 3 + self-join | 1             | 0              |
| Execution time      | ~5.0s         | ~0.05s        | ~0.02s         |
| Query complexity    | Complex CTEs  | Simple        | Simplest       |

--------------------------------------------------------------------------------
WHY IT'S FASTER:
--------------------------------------------------------------------------------

1. **ZERO JOINS**: specialty_name is in fact_encounters.

2. **PRE-COMPUTED is_readmission**: No self-join needed. ETL calculates this.

3. **PRE-COMPUTED is_inpatient**: Simple boolean filter, no string comparison.

4. **Index**: idx_fact_readmission (is_readmission, is_inpatient) optimizes this.


================================================================================
QUERY 4: Revenue by Specialty & Month
================================================================================

BUSINESS NEED:
Total allowed amounts by specialty and month. 
Which specialties generate the most revenue?

--------------------------------------------------------------------------------
ZERO-JOIN QUERY (OPTIMAL):
--------------------------------------------------------------------------------

SELECT 
    encounter_year AS year,
    encounter_month AS month,
    encounter_month_name AS month_name,
    specialty_name,
    COUNT(*) AS encounter_count,
    SUM(total_claim_amount) AS total_claimed,
    SUM(total_allowed_amount) AS total_allowed,
    ROUND(AVG(total_allowed_amount), 2) AS avg_allowed
FROM fact_encounters
GROUP BY 
    encounter_year,
    encounter_month,
    encounter_month_name,
    specialty_name
ORDER BY encounter_year, encounter_month, total_allowed DESC;

-- ZERO JOINS! Revenue metrics and specialty are all in fact_encounters.

--------------------------------------------------------------------------------
PERFORMANCE COMPARISON:
--------------------------------------------------------------------------------

| Metric              | OLTP          | Star (Before) | Star (Now)     |
|---------------------|---------------|---------------|----------------|
| Tables joined       | 4             | 2             | 0              |
| Execution time      | ~1.8s         | ~0.10s        | ~0.03s         |
| Billing table join  | Required      | Eliminated    | Eliminated     |

--------------------------------------------------------------------------------
WHY IT'S FASTER:
--------------------------------------------------------------------------------

1. **ZERO JOINS**: year, month, specialty_name, revenue all in fact table.

2. **Pre-Aggregated Billing**: total_claim_amount and total_allowed_amount 
   are calculated during ETL and stored per encounter.

3. **Composite Index**: idx_fact_specialty_year_month covers this pattern.


================================================================================
SUMMARY: PERFORMANCE IMPROVEMENTS
================================================================================

| Query | OLTP Joins | OLTP Time | Star Joins | Star Time | Speedup  |
|-------|------------|-----------|------------|-----------|----------|
| Q1    | 3          | ~1.2s     | 0          | ~0.05s    | 24x      |
| Q2    | 4          | ~3.5s     | 0 or 2     | ~0.05s    | 70x      |
| Q3    | 3+self     | ~5.0s     | 0          | ~0.02s    | 250x     |
| Q4    | 4          | ~1.8s     | 0          | ~0.03s    | 60x      |

--------------------------------------------------------------------------------
TOTAL IMPROVEMENT SUMMARY:
--------------------------------------------------------------------------------

Original (OLTP) Total Time:    ~11.5 seconds
Optimized (Star) Total Time:   ~0.15 seconds
Overall Speedup:               ~77x faster

--------------------------------------------------------------------------------
KEY OPTIMIZATION TECHNIQUES:
--------------------------------------------------------------------------------

1. **Aggressive Denormalization**: Store commonly-queried attributes directly
   in the fact table (specialty_name, year, month, department_name).

2. **Pre-Aggregated Metrics**: Store billing totals, diagnosis counts, 
   procedure counts in the fact table.

3. **Pre-Computed Flags**: Calculate is_readmission, is_inpatient during ETL.

4. **Composite Indexes**: Create indexes that match common GROUP BY patterns.

5. **Degenerate Dimensions**: Store encounter_type directly (no separate table).


================================================================================
WHEN TO USE JOINS (Drill-Through Queries)
================================================================================

Zero-join queries are optimal for AGGREGATION and REPORTING. However, you 
still need joins for DETAILED analysis:

| Use Case                      | Joins Needed | Why                        |
|-------------------------------|--------------|----------------------------|
| Monthly totals by specialty   | 0            | Denormalized in fact       |
| Patient demographic details   | 1            | Need dim_patient           |
| All diagnoses for encounter   | 1            | Need bridge_diagnoses      |
| Procedure details             | 2            | Need bridge + dim_procedure|
| Full provider info            | 1            | Need dim_provider          |

The schema supports BOTH patterns:
- **Zero-join** for fast aggregations (dashboards, KPIs)
- **Join-based** for detailed drill-through (individual records)

================================================================================
TRADE-OFFS
================================================================================

| Benefit                       | Cost                                       |
|-------------------------------|-------------------------------------------|
| Zero-join queries             | Larger fact table (more columns)          |
| Faster query execution        | More complex ETL (must denormalize)       |
| Simpler SQL for analysts      | Data duplication (specialty_name in fact) |
| Better index utilization      | Must update fact if dimension changes     |

For ANALYTICAL workloads, these trade-offs are almost always worth it.
The fact table is read millions of times; ETL runs once per day.

================================================================================
